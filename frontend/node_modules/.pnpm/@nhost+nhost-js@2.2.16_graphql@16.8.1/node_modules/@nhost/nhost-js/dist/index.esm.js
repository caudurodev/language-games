import { HasuraAuthClient as g } from "@nhost/hasura-auth-js";
export * from "@nhost/hasura-auth-js";
import { HasuraStorageClient as p } from "@nhost/hasura-storage-js";
export * from "@nhost/hasura-storage-js";
import T from "isomorphic-unfetch";
import { NhostGraphqlClient as k } from "@nhost/graphql-js";
const w = /^((?<protocol>http[s]?):\/\/)?(?<host>(localhost|local))(:(?<port>(\d+|__\w+__)))?$/;
function d(e, t) {
  const { backendUrl: i, subdomain: o, region: l } = e;
  if (i)
    return `${i}/v1/${t}`;
  if (!o)
    throw new Error("Either `backendUrl` or `subdomain` must be set.");
  const a = o.match(w);
  if (a != null && a.groups) {
    const { protocol: s, host: h, port: r } = a.groups, n = U(t);
    return n || (h === "localhost" ? (console.warn(
      'The `subdomain` is set to "localhost". Support for this will be removed in a future release. Please use "local" instead.'
    ), `${s || "http"}://localhost:${r || 1337}/v1/${t}`) : r ? `${s || "https"}://local.${t}.nhost.run:${r}/v1` : `${s || "https"}://local.${t}.nhost.run/v1`);
  }
  if (!l)
    throw new Error('`region` must be set when using a `subdomain` other than "local".');
  return `https://${o}.${t}.${l}.nhost.run/v1`;
}
function b() {
  return typeof window != "undefined";
}
function m() {
  return typeof process != "undefined" && process.env;
}
function U(e) {
  return b() || !m() ? null : process.env[`NHOST_${e.toUpperCase()}_URL`];
}
function A(e, t) {
  const o = t.startsWith("/") ? t : `/${t}`;
  return e + o;
}
function S(e) {
  const t = "subdomain" in e || "backendUrl" in e ? d(e, "auth") : e.authUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `authUrl`.");
  return new g({ url: t, ...e });
}
function $(e) {
  const t = "subdomain" in e || "backendUrl" in e ? d(e, "functions") : e.functionsUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `functionsUrl`.");
  return new v({ url: t, ...e });
}
class v {
  constructor(t) {
    const { url: i, adminSecret: o } = t;
    this.url = i, this.accessToken = null, this.adminSecret = o;
  }
  /**
   * Use `nhost.functions.call` to call (sending a POST request to) a serverless function. Use generic
   * types to specify the expected response data, request body and error message.
   *
   * @example
   * ### Without generic types
   * ```ts
   * await nhost.functions.call('send-welcome-email', { email: 'joe@example.com', name: 'Joe Doe' })
   * ```
   *
   * @example
   * ### Using generic types
   * ```ts
   * type Data = {
   *   message: string
   * }
   *
   * type Body = {
   *   email: string
   *   name: string
   * }
   *
   * type ErrorMessage = {
   *   details: string
   * }
   *
   * // The function will only accept a body of type `Body`
   * const { res, error } = await nhost.functions.call<Data, Body, ErrorMessage>(
   *   'send-welcome-email',
   *   { email: 'joe@example.com', name: 'Joe Doe' }
   * )
   *
   * // Now the response data is typed as `Data`
   * console.log(res?.data.message)
   *
   * // Now the error message is typed as `ErrorMessage`
   * console.log(error?.message.details)
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/call
   */
  async call(t, i, o) {
    var s, h;
    const l = {
      "Content-Type": "application/json",
      ...this.generateAccessTokenHeaders(),
      ...o == null ? void 0 : o.headers
    }, a = A(this.url, t);
    try {
      const r = await T(a, {
        body: i ? JSON.stringify(i) : null,
        headers: l,
        method: "POST"
      });
      if (!r.ok) {
        let c;
        return (s = r.headers.get("content-type")) != null && s.includes("application/json") ? c = await r.json() : c = await r.text(), {
          res: null,
          error: {
            message: c,
            error: r.statusText,
            status: r.status
          }
        };
      }
      let n;
      return (h = r.headers.get("content-type")) != null && h.includes("application/json") ? n = await r.json() : n = await r.text(), {
        res: { data: n, status: r.status, statusText: r.statusText },
        error: null
      };
    } catch (r) {
      const n = r;
      return {
        res: null,
        error: {
          message: n.message,
          status: n.name === "AbortError" ? 0 : 500,
          error: n.name === "AbortError" ? "abort-error" : "unknown"
        }
      };
    }
  }
  /**
   * Use `nhost.functions.setAccessToken` to a set an access token to be used in subsequent functions requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.functions.setAccessToken('some-access-token')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/set-access-token
   */
  setAccessToken(t) {
    if (!t) {
      this.accessToken = null;
      return;
    }
    this.accessToken = t;
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
}
function C(e) {
  const t = "subdomain" in e || "backendUrl" in e ? d(e, "graphql") : e.graphqlUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `graphqlUrl`.");
  return new k({ url: t, ...e });
}
function E(e) {
  const t = "subdomain" in e || "backendUrl" in e ? d(e, "storage") : e.storageUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `storageUrl`.");
  return new p({ url: t, ...e });
}
const H = (e) => new _(e);
class _ {
  /**
   * Nhost Client
   *
   * @example
   * ```ts
   * const nhost = new NhostClient({ subdomain, region });
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript
   */
  constructor({
    refreshIntervalTime: t,
    clientStorage: i,
    clientStorageType: o,
    autoRefreshToken: l,
    autoSignIn: a,
    adminSecret: s,
    devTools: h,
    start: r = !0,
    ...n
  }) {
    this.auth = S({
      refreshIntervalTime: t,
      clientStorage: i,
      clientStorageType: o,
      autoRefreshToken: l,
      autoSignIn: a,
      start: r,
      ...n
    }), this.storage = E({ adminSecret: s, ...n }), this.functions = $({ adminSecret: s, ...n }), this.graphql = C({ adminSecret: s, ...n }), this.auth.onAuthStateChanged((c, u) => {
      if (c === "SIGNED_OUT") {
        this.storage.setAccessToken(void 0), this.functions.setAccessToken(void 0), this.graphql.setAccessToken(void 0);
        return;
      }
      const f = u == null ? void 0 : u.accessToken;
      this.storage.setAccessToken(f), this.functions.setAccessToken(f), this.graphql.setAccessToken(f);
    }), this.auth.onTokenChanged((c) => {
      const u = c == null ? void 0 : c.accessToken;
      this.storage.setAccessToken(u), this.functions.setAccessToken(u), this.graphql.setAccessToken(u);
    }), this._adminSecret = s, this.devTools = h;
  }
  get adminSecret() {
    return this._adminSecret;
  }
  set adminSecret(t) {
    this._adminSecret = t, this.storage.setAdminSecret(t);
  }
}
export {
  _ as NhostClient,
  v as NhostFunctionsClient,
  S as createAuthClient,
  $ as createFunctionsClient,
  C as createGraphqlClient,
  H as createNhostClient,
  E as createStorageClient
};
//# sourceMappingURL=index.esm.js.map
