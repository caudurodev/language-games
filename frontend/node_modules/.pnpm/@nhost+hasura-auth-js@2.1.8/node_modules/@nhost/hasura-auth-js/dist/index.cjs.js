"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const Ge=require("jwt-decode"),l=require("xstate"),G=require("js-cookie"),He=require("fetch-ponyfill"),v="nhostRefreshToken",P="nhostRefreshTokenId",R="nhostRefreshTokenExpiresAt",Z=3,ee=60,H=5,B=0,Q=1,p=10,O=20;class b extends Error{constructor(e){super(e.message),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),e instanceof Error?(this.name=e.name,this.error={error:e.name,status:Q,message:e.message}):(this.name=e.error,this.error=e)}}const y={status:p,error:"invalid-email",message:"Email is incorrectly formatted"},re={status:p,error:"invalid-mfa-type",message:"MFA type is invalid"},se={status:p,error:"invalid-mfa-code",message:"MFA code is invalid"},x={status:p,error:"invalid-password",message:"Password is incorrectly formatted"},q={status:p,error:"invalid-phone-number",message:"Phone number is incorrectly formatted"},te={status:p,error:"invalid-mfa-ticket",message:"MFA ticket is invalid"},ne={status:p,error:"no-mfa-ticket",message:"No MFA ticket has been provided"},ie={status:p,error:"no-refresh-token",message:"No refresh token has been provided"},oe={status:O,error:"refresher-already-running",message:"The token refresher is already running. You must wait until is has finished before submitting a new token."},w={status:O,error:"already-signed-in",message:"User is already signed in"},ae={status:O,error:"unauthenticated-user",message:"User is not authenticated"},qe={status:O,error:"user-not-anonymous",message:"User is not anonymous"},ce={status:O,error:"unverified-user",message:"Email needs verification"},ue={status:p,error:"invalid-refresh-token",message:"Invalid or expired refresh token"},le={status:Q,error:"invalid-sign-in-method",message:"Invalid sign-in method"},D={user:null,mfa:null,accessToken:{value:null,expiresAt:null,expiresInSeconds:15},refreshTimer:{startedAt:null,attempts:0,lastAttempt:null},refreshToken:{value:null},importTokenAttempts:0,errors:{}};function We(t){return new TextEncoder().encode(t)}function k(t){const e=new Uint8Array(t);let r="";for(const n of e)r+=String.fromCharCode(n);return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function z(t){const e=t.replace(/-/g,"+").replace(/_/g,"/"),r=(4-e.length%4)%4,s=e.padEnd(e.length+r,"="),n=atob(s),i=new ArrayBuffer(n.length),u=new Uint8Array(i);for(let h=0;h<n.length;h++)u[h]=n.charCodeAt(h);return i}function de(){return(window==null?void 0:window.PublicKeyCredential)!==void 0&&typeof window.PublicKeyCredential=="function"}function he(t){const{id:e}=t;return{...t,id:z(e),transports:t.transports}}function fe(t){return t==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(t)}class g extends Error{constructor(e,r="WebAuthnError"){super(e),this.name=r}}function Fe({error:t,options:e}){var r,s;const{publicKey:n}=e;if(!n)throw Error("options was missing required publicKey property");if(t.name==="AbortError"){if(e.signal===new AbortController().signal)return new g("Registration ceremony was sent an abort signal","AbortError")}else if(t.name==="ConstraintError"){if(((r=n.authenticatorSelection)===null||r===void 0?void 0:r.requireResidentKey)===!0)return new g("Discoverable credentials were required but no available authenticator supported it","ConstraintError");if(((s=n.authenticatorSelection)===null||s===void 0?void 0:s.userVerification)==="required")return new g("User verification was required but no available authenticator supported it","ConstraintError")}else{if(t.name==="InvalidStateError")return new g("The authenticator was previously registered","InvalidStateError");if(t.name==="NotAllowedError")return new g("User clicked cancel, or the registration ceremony timed out","NotAllowedError");if(t.name==="NotSupportedError")return n.pubKeyCredParams.filter(u=>u.type==="public-key").length===0?new g('No entry in pubKeyCredParams was of type "public-key"',"NotSupportedError"):new g("No available authenticator supported any of the specified pubKeyCredParams algorithms","NotSupportedError");if(t.name==="SecurityError"){const i=window.location.hostname;if(fe(i)){if(n.rp.id!==i)return new g(`The RP ID "${n.rp.id}" is invalid for this domain`,"SecurityError")}else return new g(`${window.location.hostname} is an invalid domain`,"SecurityError")}else if(t.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new g("User ID was not between 1 and 64 characters","TypeError")}else if(t.name==="UnknownError")return new g("The authenticator was unable to process the specified options, or could not create a new credential","UnknownError")}return t}class $e{createNewAbortSignal(){return this.controller&&this.controller.abort(),this.controller=new AbortController,this.controller.signal}reset(){this.controller=void 0}}const U=new $e;async function me(t){if(!de())throw new Error("WebAuthn is not supported in this browser");const r={publicKey:{...t,challenge:z(t.challenge),user:{...t.user,id:We(t.user.id)},excludeCredentials:t.excludeCredentials.map(he)}};r.signal=U.createNewAbortSignal();let s;try{s=await navigator.credentials.create(r)}catch(m){throw Fe({error:m,options:r})}finally{U.reset()}if(!s)throw new Error("Registration was not completed");const{id:n,rawId:i,response:u,type:h}=s,f={id:n,rawId:k(i),response:{attestationObject:k(u.attestationObject),clientDataJSON:k(u.clientDataJSON)},type:h,clientExtensionResults:s.getClientExtensionResults(),authenticatorAttachment:s.authenticatorAttachment};return typeof u.getTransports=="function"&&(f.transports=u.getTransports()),f}function Ye(t){return new TextDecoder("utf-8").decode(t)}async function je(){if(navigator.credentials.conditionalMediationSupported)return!0;const t=window.PublicKeyCredential;return t.isConditionalMediationAvailable!==void 0&&t.isConditionalMediationAvailable()}function Be({error:t,options:e}){var r;const{publicKey:s}=e;if(!s)throw Error("options was missing required publicKey property");if(t.name==="AbortError"){if(e.signal===new AbortController().signal)return new g("Authentication ceremony was sent an abort signal","AbortError")}else{if(t.name==="NotAllowedError")return!((r=s.allowCredentials)===null||r===void 0)&&r.length?new g("No available authenticator recognized any of the allowed credentials","NotAllowedError"):new g("User clicked cancel, or the authentication ceremony timed out","NotAllowedError");if(t.name==="SecurityError"){const n=window.location.hostname;if(fe(n)){if(s.rpId!==n)return new g(`The RP ID "${s.rpId}" is invalid for this domain`,"SecurityError")}else return new g(`${window.location.hostname} is an invalid domain`,"SecurityError")}else if(t.name==="UnknownError")return new g("The authenticator was unable to process the specified options, or could not create a new assertion signature","UnknownError")}return t}async function Qe(t,e=!1){var r,s;if(!de())throw new Error("WebAuthn is not supported in this browser");let n;((r=t.allowCredentials)===null||r===void 0?void 0:r.length)!==0&&(n=(s=t.allowCredentials)===null||s===void 0?void 0:s.map(he));const i={...t,challenge:z(t.challenge),allowCredentials:n},u={};if(e){if(!await je())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete*='webauthn']").length<1)throw Error('No <input> with `"webauthn"` in its `autocomplete` attribute was detected');u.mediation="conditional",i.allowCredentials=[]}u.publicKey=i,u.signal=U.createNewAbortSignal();let h;try{h=await navigator.credentials.get(u)}catch(d){throw Be({error:d,options:u})}finally{U.reset()}if(!h)throw new Error("Authentication was not completed");const{id:f,rawId:m,response:a,type:o}=h;let c;return a.userHandle&&(c=Ye(a.userHandle)),{id:f,rawId:k(m),response:{authenticatorData:k(a.authenticatorData),clientDataJSON:k(a.clientDataJSON),signature:k(a.signature),userHandle:c},type:o,clientExtensionResults:h.getClientExtensionResults(),authenticatorAttachment:h.authenticatorAttachment}}const L=typeof window!="undefined",M=new Map,ze=t=>{var e;return L&&typeof localStorage!="undefined"?localStorage.getItem(t):(e=M.get(t))!=null?e:null},Xe=(t,e)=>{L&&typeof localStorage!="undefined"?e?localStorage.setItem(t,e):localStorage.removeItem(t):e?M.set(t,e):M.has(t)&&M.delete(t)},Ee=(t,e)=>{if(t==="localStorage"||t==="web")return ze;if(t==="cookie")return r=>{var s;return L&&(s=G.get(r))!=null?s:null};if(!e)throw Error(`clientStorageType is set to '${t}' but no clientStorage has been given`);if(t==="react-native")return r=>{var s;return(s=e.getItem)==null?void 0:s.call(e,r)};if(t==="capacitor")return r=>{var s;return(s=e.get)==null?void 0:s.call(e,{key:r})};if(t==="expo-secure-storage")return r=>{var s;return(s=e.getItemAsync)==null?void 0:s.call(e,r)};if(t==="custom"){if(e.getItem&&e.removeItem)return e.getItem;if(e.getItemAsync)return e.getItemAsync;throw Error(`clientStorageType is set to 'custom' but clientStorage is missing either "getItem" and "removeItem" properties or "getItemAsync" property`)}throw Error(`Unknown storage type: ${t}`)},ge=(t,e)=>{if(t==="localStorage"||t==="web")return Xe;if(t==="cookie")return(r,s)=>{L&&(s?G.set(r,s,{expires:30,sameSite:"lax",httpOnly:!1}):G.remove(r))};if(!e)throw Error(`clientStorageType is set to '${t}' but no clienStorage has been given`);if(t==="react-native")return(r,s)=>{var n,i;return s?(n=e.setItem)==null?void 0:n.call(e,r,s):(i=e.removeItem)==null?void 0:i.call(e,r)};if(t==="capacitor")return(r,s)=>{var n,i;return s?(n=e.set)==null?void 0:n.call(e,{key:r,value:s}):(i=e.remove)==null?void 0:i.call(e,{key:r})};if(t==="expo-secure-storage")return async(r,s)=>{var n,i;return s?(n=e.setItemAsync)==null?void 0:n.call(e,r,s):(i=e.deleteItemAsync)==null?void 0:i.call(e,r)};if(t==="custom"){if(!e.removeItem)throw Error("clientStorageType is set to 'custom' but clientStorage is missing a removeItem property");if(e.setItem)return(r,s)=>{var n,i;return s?(n=e.setItem)==null?void 0:n.call(e,r,s):(i=e.removeItem)==null?void 0:i.call(e,r)};if(e.setItemAsync)return async(r,s)=>{var n,i;return s?(n=e.setItemAsync)==null?void 0:n.call(e,r,s):(i=e.removeItem)==null?void 0:i.call(e,r)};throw Error("clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property")}throw Error(`Unknown storage type: ${t}`)},N=t=>!t||!t.accessToken.value||!t.refreshToken.value||!t.accessToken.expiresAt||!t.user?null:{accessToken:t.accessToken.value,accessTokenExpiresIn:(t.accessToken.expiresAt.getTime()-Date.now())/1e3,refreshToken:t.refreshToken.value,user:t.user},I=({accessToken:t,isError:e,user:r,error:s})=>e?{session:null,error:s}:r&&t?{session:{accessToken:t,accessTokenExpiresIn:0,refreshToken:"",user:r},error:null}:{session:null,error:null},K=()=>typeof window!="undefined",{fetch:Je}=He(),Te=async(t,e,{token:r,body:s}={})=>{const n={"Content-Type":"application/json",Accept:"*/*"};r&&(n.Authorization=`Bearer ${r}`);const i={method:e,headers:n};s&&(i.body=JSON.stringify(s));try{const u=await Je(t,i);if(!u.ok){const h=await u.json();return Promise.reject({error:h})}try{return{data:await u.json(),error:null}}catch{return console.warn(`Unexpected response: can't parse the response of the server at ${t}`),{data:"OK",error:null}}}catch{const h={message:"Network Error",status:B,error:"network"};return Promise.reject({error:h})}},_=async(t,e,r)=>Te(t,"POST",{token:r,body:e}),pe=(t,e)=>Te(t,"GET",{token:e}),X=(t,e)=>{const r=e&&Object.entries(e).map(([s,n])=>{const i=Array.isArray(n)?n.join(","):typeof n=="object"?JSON.stringify(n):n;return`${s}=${encodeURIComponent(i)}`}).join("&");return r?`${t}?${r}`:t},T=(t,e)=>{if(!(e!=null&&e.redirectTo))return e;const{redirectTo:r,...s}=e;if(!t)return r.startsWith("/")?s:e;const n=new URL(t),i=Object.fromEntries(new URLSearchParams(n.search)),u=new URL(r.startsWith("/")?n.origin+r:r),h=new URLSearchParams(u.search);let f=Object.fromEntries(h);r.startsWith("/")&&(f={...i,...f});let m=n.pathname;return u.pathname.length>1&&(m+=u.pathname.slice(1)),{...s,redirectTo:X(u.origin+m,f)}};function C(t,e){var n;if(!e){if(typeof window=="undefined")return;e=((n=window.location)==null?void 0:n.href)||""}t=t.replace(/[\[\]]/g,"\\$&");const r=new RegExp("[?&#]"+t+"(=([^&#]*)|&|#|$)"),s=r.exec(e);return s?s[2]?decodeURIComponent(s[2].replace(/\+/g," ")):"":null}function W(t){var r;if(typeof window=="undefined")return;const e=window==null?void 0:window.location;if(e&&e){const s=new URLSearchParams(e.search),n=new URLSearchParams((r=e.hash)==null?void 0:r.slice(1));s.delete(t),n.delete(t);let i=window.location.pathname;Array.from(s).length&&(i+=`?${s.toString()}`),Array.from(n).length&&(i+=`#${n.toString()}`),window.history.pushState({},"",i)}}const A=t=>!!t&&typeof t=="string"&&!!String(t).toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/),V=t=>!!t&&typeof t=="string"&&t.length>=Z,F=t=>!!t&&typeof t=="string",we=t=>t&&typeof t=="string"&&t.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i),Se=({backendUrl:t,clientUrl:e,clientStorageType:r="web",clientStorage:s,refreshIntervalTime:n,autoRefreshToken:i=!0,autoSignIn:u=!0})=>{const h=Ee(r,s),f=ge(r,s),m=async(a,o,c)=>(await _(`${t}${a}`,o,c)).data;return l.createMachine({schema:{context:{},events:{},services:{}},tsTypes:{},context:D,predictableActionArguments:!0,id:"nhost",type:"parallel",states:{authentication:{initial:"starting",on:{SESSION_UPDATE:[{cond:"hasSession",actions:["saveSession","resetTimer","reportTokenChanged"],target:".signedIn"}]},states:{starting:{tags:["loading"],always:{cond:"isSignedIn",target:"signedIn"},invoke:{id:"importRefreshToken",src:"importRefreshToken",onDone:[{cond:"hasSession",actions:["saveSession","reportTokenChanged"],target:"signedIn"},{target:"signedOut"}],onError:[{cond:"shouldRetryImportToken",actions:"incrementTokenImportAttempts",target:"retryTokenImport"},{actions:["saveAuthenticationError"],target:"signedOut"}]}},retryTokenImport:{tags:["loading"],after:{RETRY_IMPORT_TOKEN_DELAY:"starting"}},signedOut:{initial:"noErrors",entry:"reportSignedOut",states:{noErrors:{},success:{},needsSmsOtp:{},needsMfa:{},failed:{},signingOut:{entry:["clearContextExceptRefreshToken"],exit:["destroyRefreshToken","reportTokenChanged"],invoke:{src:"signout",id:"signingOut",onDone:{target:"success"},onError:{target:"failed",actions:["saveAuthenticationError"]}}}},on:{SIGNIN_PASSWORD:"authenticating.password",SIGNIN_ANONYMOUS:"authenticating.anonymous",SIGNIN_SECURITY_KEY_EMAIL:"authenticating.securityKeyEmail",SIGNIN_MFA_TOTP:"authenticating.mfa.totp",SIGNIN_PAT:"authenticating.pat"}},authenticating:{entry:"resetErrors",states:{password:{invoke:{src:"signInPassword",id:"authenticateUserWithPassword",onDone:[{cond:"hasMfaTicket",actions:["saveMfaTicket"],target:"#nhost.authentication.signedOut.needsMfa"},{actions:["saveSession","reportTokenChanged"],target:"#nhost.authentication.signedIn"}],onError:[{cond:"unverified",target:["#nhost.authentication.signedOut","#nhost.registration.incomplete.needsEmailVerification"]},{actions:"saveAuthenticationError",target:"#nhost.authentication.signedOut.failed"}]}},pat:{invoke:{src:"signInPAT",id:"authenticateWithPAT",onDone:{actions:["savePATSession","reportTokenChanged"],target:"#nhost.authentication.signedIn"},onError:{actions:"saveAuthenticationError",target:"#nhost.authentication.signedOut.failed"}}},anonymous:{invoke:{src:"signInAnonymous",id:"authenticateAnonymously",onDone:{actions:["saveSession","reportTokenChanged"],target:"#nhost.authentication.signedIn"},onError:{actions:"saveAuthenticationError",target:"#nhost.authentication.signedOut.failed"}}},mfa:{states:{totp:{invoke:{src:"signInMfaTotp",id:"signInMfaTotp",onDone:{actions:["saveSession","reportTokenChanged"],target:"#nhost.authentication.signedIn"},onError:{actions:["saveAuthenticationError"],target:"#nhost.authentication.signedOut.failed"}}}}},securityKeyEmail:{invoke:{src:"signInSecurityKeyEmail",id:"authenticateUserWithSecurityKey",onDone:{actions:["saveSession","reportTokenChanged"],target:"#nhost.authentication.signedIn"},onError:[{cond:"unverified",target:["#nhost.authentication.signedOut","#nhost.registration.incomplete.needsEmailVerification"]},{actions:"saveAuthenticationError",target:"#nhost.authentication.signedOut.failed"}]}}}},signedIn:{type:"parallel",entry:["reportSignedIn","cleanUrl","broadcastToken","resetErrors"],on:{SIGNOUT:"signedOut.signingOut"},states:{refreshTimer:{id:"timer",initial:"idle",states:{disabled:{type:"final"},stopped:{always:{cond:"noToken",target:"idle"}},idle:{always:[{cond:"isAutoRefreshDisabled",target:"disabled"},{cond:"isRefreshTokenPAT",target:"disabled"},{cond:"hasRefreshToken",target:"running"}]},running:{initial:"pending",entry:"resetTimer",states:{pending:{after:{1e3:{internal:!1,target:"pending"}},always:{cond:"refreshTimerShouldRefresh",target:"refreshing"}},refreshing:{invoke:{src:"refreshToken",id:"refreshToken",onDone:{actions:["saveSession","resetTimer","reportTokenChanged"],target:"pending"},onError:[{actions:"saveRefreshAttempt",target:"pending"}]}}}}}}}}}},token:{initial:"idle",states:{idle:{on:{TRY_TOKEN:"running"},initial:"noErrors",states:{noErrors:{},error:{}}},running:{invoke:{src:"refreshToken",id:"authenticateWithToken",onDone:{actions:["saveSession","reportTokenChanged"],target:["#nhost.authentication.signedIn","idle.noErrors"]},onError:[{cond:"isSignedIn",target:"idle.error"},{actions:"saveAuthenticationError",target:["#nhost.authentication.signedOut.failed","idle.error"]}]}}}},registration:{initial:"incomplete",on:{SIGNED_IN:[{cond:"isAnonymous",target:".incomplete"},".complete"]},states:{incomplete:{on:{SIGNUP_EMAIL_PASSWORD:"emailPassword",SIGNUP_SECURITY_KEY:"securityKey",PASSWORDLESS_EMAIL:"passwordlessEmail",PASSWORDLESS_SMS:"passwordlessSms",PASSWORDLESS_SMS_OTP:"passwordlessSmsOtp"},initial:"noErrors",states:{noErrors:{},needsEmailVerification:{},needsOtp:{},failed:{}}},emailPassword:{entry:["resetErrors"],invoke:{src:"signUpEmailPassword",id:"signUpEmailPassword",onDone:[{cond:"hasSession",actions:["saveSession","reportTokenChanged"],target:"#nhost.authentication.signedIn"},{actions:"clearContext",target:["#nhost.authentication.signedOut","incomplete.needsEmailVerification"]}],onError:[{cond:"unverified",target:"incomplete.needsEmailVerification"},{actions:"saveRegistrationError",target:"incomplete.failed"}]}},securityKey:{entry:["resetErrors"],invoke:{src:"signUpSecurityKey",id:"signUpSecurityKey",onDone:[{cond:"hasSession",actions:["saveSession","reportTokenChanged"],target:"#nhost.authentication.signedIn"},{actions:"clearContext",target:["#nhost.authentication.signedOut","incomplete.needsEmailVerification"]}],onError:[{cond:"unverified",target:"incomplete.needsEmailVerification"},{actions:"saveRegistrationError",target:"incomplete.failed"}]}},passwordlessEmail:{entry:["resetErrors"],invoke:{src:"passwordlessEmail",id:"passwordlessEmail",onDone:{actions:"clearContext",target:["#nhost.authentication.signedOut","incomplete.needsEmailVerification"]},onError:{actions:"saveRegistrationError",target:"incomplete.failed"}}},passwordlessSms:{entry:["resetErrors"],invoke:{src:"passwordlessSms",id:"passwordlessSms",onDone:{actions:"clearContext",target:["#nhost.authentication.signedOut","incomplete.needsOtp"]},onError:{actions:"saveRegistrationError",target:"incomplete.failed"}}},passwordlessSmsOtp:{entry:["resetErrors"],invoke:{src:"passwordlessSmsOtp",id:"passwordlessSmsOtp",onDone:{actions:["saveSession","reportTokenChanged"],target:"#nhost.authentication.signedIn"},onError:{actions:"saveRegistrationError",target:"incomplete.failed"}}},complete:{on:{SIGNED_OUT:"incomplete"}}}}}},{actions:{reportSignedIn:l.send("SIGNED_IN"),reportSignedOut:l.send("SIGNED_OUT"),reportTokenChanged:l.send("TOKEN_CHANGED"),incrementTokenImportAttempts:l.assign({importTokenAttempts:({importTokenAttempts:a})=>a+1}),clearContext:l.assign(()=>(f(R,null),f(v,null),f(P,null),{...D})),clearContextExceptRefreshToken:l.assign(({refreshToken:{value:a}})=>(f(R,null),{...D,refreshToken:{value:a}})),saveSession:l.assign({user:(a,{data:o})=>{var c;return((c=o==null?void 0:o.session)==null?void 0:c.user)||null},accessToken:(a,{data:o})=>{if(o.session){const{accessTokenExpiresIn:c,accessToken:d}=o.session,E=new Date(Date.now()+c*1e3);return f(R,E.toISOString()),{value:d,expiresAt:E,expiresInSeconds:c}}return f(R,null),{value:null,expiresAt:null,expiresInSeconds:null}},refreshToken:(a,{data:o})=>{var E,S;const c=((E=o.session)==null?void 0:E.refreshToken)||null,d=((S=o.session)==null?void 0:S.refreshTokenId)||null;return c&&f(v,c),d&&f(P,d),{value:c}}}),savePATSession:l.assign({user:(a,{data:o})=>{var c;return((c=o==null?void 0:o.session)==null?void 0:c.user)||null},accessToken:(a,{data:o})=>{if(o.session){const{accessTokenExpiresIn:c,accessToken:d}=o.session,E=new Date(Date.now()+c*1e3);return f(R,E.toISOString()),{value:d,expiresAt:E,expiresInSeconds:c}}return f(R,null),{value:null,expiresAt:null,expiresInSeconds:null}},refreshToken:(a,{data:o})=>{var E,S;const c=((E=o.session)==null?void 0:E.refreshToken)||null,d=((S=o.session)==null?void 0:S.refreshTokenId)||null;return c&&f(v,c),d&&f(P,d),{value:c,isPAT:!0}}}),saveMfaTicket:l.assign({mfa:(a,o)=>{var c;return(c=o.data)==null?void 0:c.mfa}}),resetTimer:l.assign({refreshTimer:a=>({startedAt:new Date,attempts:0,lastAttempt:null})}),saveRefreshAttempt:l.assign({refreshTimer:(a,o)=>({startedAt:a.refreshTimer.startedAt,attempts:a.refreshTimer.attempts+1,lastAttempt:new Date})}),saveAuthenticationError:l.assign({errors:({errors:a},{data:{error:o}})=>({...a,authentication:o})}),resetErrors:l.assign({errors:a=>({}),importTokenAttempts:a=>0}),saveRegistrationError:l.assign({errors:({errors:a},{data:{error:o}})=>({...a,registration:o})}),destroyRefreshToken:l.assign({refreshToken:a=>(f(v,null),f(P,null),{value:null})}),cleanUrl:()=>{u&&C("refreshToken")&&(W("refreshToken"),W("type"))},broadcastToken:a=>{if(u)try{new BroadcastChannel("nhost").postMessage(a.refreshToken.value)}catch{}}},guards:{isAnonymous:(a,o)=>{var c;return!!((c=a.user)!=null&&c.isAnonymous)},isSignedIn:a=>!!a.user&&!!a.refreshToken.value&&!!a.accessToken.value,noToken:a=>!a.refreshToken.value,isRefreshTokenPAT:a=>{var o;return!!((o=a.refreshToken)!=null&&o.isPAT)},hasRefreshToken:a=>!!a.refreshToken.value,isAutoRefreshDisabled:()=>!i,refreshTimerShouldRefresh:a=>{const{expiresAt:o}=a.accessToken;if(!o)return!1;if(a.refreshTimer.lastAttempt)return a.refreshTimer.attempts>H?!1:Date.now()-a.refreshTimer.lastAttempt.getTime()>Math.pow(2,a.refreshTimer.attempts-1)*5e3;if(n&&Date.now()-a.refreshTimer.startedAt.getTime()>n*1e3)return!0;const c=a.accessToken.expiresInSeconds;return c?o.getTime()-Date.now()-1e3*Math.min(ee,c*.5)<=0:!1},shouldRetryImportToken:(a,o)=>a.importTokenAttempts<H&&(o.data.error.status===B||o.data.error.status>=500),unverified:(a,{data:{error:o}})=>o.status===401&&(o.message==="Email is not verified"||o.error==="unverified-user"),hasSession:(a,o)=>{var c;return!!((c=o.data)!=null&&c.session)},hasMfaTicket:(a,o)=>{var c;return!!((c=o.data)!=null&&c.mfa)}},services:{signInPassword:(a,{email:o,password:c})=>A(o)?V(c)?m("/signin/email-password",{email:o,password:c}):Promise.reject({error:x}):Promise.reject({error:y}),signInPAT:(a,{pat:o})=>m("/signin/pat",{personalAccessToken:o}),passwordlessSms:(a,{phoneNumber:o,options:c})=>{var d;return F(o)?(d=a.user)!=null&&d.isAnonymous?(console.warn("Deanonymisation from a phone number is not yet implemented in hasura-auth"),m("/user/deanonymize",{signInMethod:"passwordless",connection:"sms",phoneNumber:o,options:T(e,c)},a.accessToken.value)):m("/signin/passwordless/sms",{phoneNumber:o,options:T(e,c)}):Promise.reject({error:q})},passwordlessSmsOtp:(a,{phoneNumber:o,otp:c})=>F(o)?m("/signin/passwordless/sms/otp",{phoneNumber:o,otp:c}):Promise.reject({error:q}),passwordlessEmail:(a,{email:o,options:c})=>{var d;return A(o)?(d=a.user)!=null&&d.isAnonymous?m("/user/deanonymize",{signInMethod:"passwordless",connection:"email",email:o,options:T(e,c)},a.accessToken.value):m("/signin/passwordless/email",{email:o,options:T(e,c)}):Promise.reject({error:y})},signInAnonymous:a=>m("/signin/anonymous"),signInMfaTotp:(a,o)=>{var d;const c=o.ticket||((d=a.mfa)==null?void 0:d.ticket);return c?we(c)?m("/signin/mfa/totp",{ticket:c,otp:o.otp}):Promise.reject({error:te}):Promise.reject({error:ne})},signInSecurityKeyEmail:async(a,{email:o})=>{if(!A(o))throw new b(y);const c=await m("/signin/webauthn",{email:o});let d;try{d=await Qe(c)}catch(E){throw new b(E)}return m("/signin/webauthn/verify",{email:o,credential:d})},refreshToken:async(a,o)=>{const c=o.type==="TRY_TOKEN"?o.token:a.refreshToken.value;return{session:await m("/token",{refreshToken:c}),error:null}},signout:(a,o)=>m("/signout",{refreshToken:a.refreshToken.value,all:!!o.all}),signUpEmailPassword:async(a,{email:o,password:c,options:d})=>{var E;return A(o)?V(c)?(E=a.user)!=null&&E.isAnonymous?m("/user/deanonymize",{signInMethod:"email-password",email:o,password:c,options:T(e,d)},a.accessToken.value):m("/signup/email-password",{email:o,password:c,options:T(e,d)}):Promise.reject({error:x}):Promise.reject({error:y})},signUpSecurityKey:async(a,{email:o,options:c})=>{if(!A(o))return Promise.reject({error:y});const d=c==null?void 0:c.nickname;d&&delete c.nickname;const E=await m("/signup/webauthn",{email:o,options:c});let S;try{S=await me(E)}catch(Le){throw new b(Le)}return m("/signup/webauthn/verify",{credential:S,options:{redirectTo:c==null?void 0:c.redirectTo,nickname:d}})},importRefreshToken:async a=>{if(a.user&&a.refreshToken.value&&a.accessToken.value&&a.accessToken.expiresAt)return{session:{accessToken:a.accessToken.value,accessTokenExpiresIn:a.accessToken.expiresAt.getTime()-Date.now(),refreshToken:a.refreshToken.value,user:a.user},error:null};let o=null;if(u){const d=C("refreshToken")||null;if(d)try{return{session:await m("/token",{refreshToken:d}),error:null}}catch(E){o=E.error}else{const E=C("error");if(E)return Promise.reject({session:null,error:{status:p,error:E,message:C("errorDescription")||E}})}}const c=await h(v);if(c)try{return{session:await m("/token",{refreshToken:c}),error:null}}catch(d){o=d.error}return o?Promise.reject({error:o,session:null}):{error:null,session:null}}},delays:{RETRY_IMPORT_TOKEN_DELAY:({importTokenAttempts:a})=>Math.pow(2,a-1)*5e3}})},_e=({backendUrl:t,clientUrl:e,interpreter:r})=>l.createMachine({schema:{context:{},events:{},services:{}},tsTypes:{},predictableActionArguments:!0,id:"changeEmail",initial:"idle",context:{error:null},states:{idle:{on:{REQUEST:[{cond:"invalidEmail",actions:"saveInvalidEmailError",target:".error"},{target:"requesting"}]},initial:"initial",states:{initial:{},success:{},error:{}}},requesting:{invoke:{src:"requestChange",id:"requestChange",onDone:{target:"idle.success",actions:"reportSuccess"},onError:{actions:["saveRequestError","reportError"],target:"idle.error"}}}}},{actions:{saveInvalidEmailError:l.assign({error:s=>y}),saveRequestError:l.assign({error:(s,{data:{error:n}})=>n}),reportError:l.send(s=>({type:"ERROR",error:s.error})),reportSuccess:l.send("SUCCESS")},guards:{invalidEmail:(s,{email:n})=>!A(n)},services:{requestChange:async(s,{email:n,options:i})=>(await _(`${t}/user/email/change`,{newEmail:n,options:T(e,i)},r==null?void 0:r.getSnapshot().context.accessToken.value)).data}}),Ie=({backendUrl:t,interpreter:e})=>l.createMachine({schema:{context:{},events:{},services:{}},tsTypes:{},predictableActionArguments:!0,id:"changePassword",initial:"idle",context:{error:null},states:{idle:{on:{REQUEST:[{cond:"invalidPassword",actions:"saveInvalidPasswordError",target:".error"},{target:"requesting"}]},initial:"initial",states:{initial:{},success:{},error:{}}},requesting:{invoke:{src:"requestChange",id:"requestChange",onDone:{target:"idle.success",actions:"reportSuccess"},onError:{actions:["saveRequestError","reportError"],target:"idle.error"}}}}},{actions:{saveInvalidPasswordError:l.assign({error:r=>x}),saveRequestError:l.assign({error:(r,{data:{error:s}})=>s}),reportError:l.send(r=>({type:"ERROR",error:r.error})),reportSuccess:l.send("SUCCESS")},guards:{invalidPassword:(r,{password:s})=>!V(s)},services:{requestChange:(r,{password:s,ticket:n})=>_(`${t}/user/password`,{newPassword:s,ticket:n},e==null?void 0:e.getSnapshot().context.accessToken.value)}}),Ze=({backendUrl:t,interpreter:e})=>l.createMachine({schema:{context:{},events:{}},tsTypes:{},predictableActionArguments:!0,id:"enableMfa",initial:"idle",context:{error:null,imageUrl:null,secret:null},states:{idle:{initial:"initial",on:{GENERATE:"generating"},states:{initial:{},error:{}}},generating:{invoke:{src:"generate",id:"generate",onDone:{target:"generated",actions:["reportGeneratedSuccess","saveGeneration"]},onError:{actions:["saveError","reportGeneratedError"],target:"idle.error"}}},generated:{initial:"idle",states:{idle:{initial:"idle",on:{ACTIVATE:[{cond:"invalidMfaType",actions:"saveInvalidMfaTypeError",target:".error"},{cond:"invalidMfaCode",actions:"saveInvalidMfaCodeError",target:".error"},{target:"activating"}]},states:{idle:{},error:{}}},activating:{invoke:{src:"activate",id:"activate",onDone:{target:"activated",actions:"reportSuccess"},onError:{actions:["saveError","reportError"],target:"idle.error"}}},activated:{type:"final"}}}}},{actions:{saveInvalidMfaTypeError:l.assign({error:r=>re}),saveInvalidMfaCodeError:l.assign({error:r=>se}),saveError:l.assign({error:(r,{data:{error:s}})=>s}),saveGeneration:l.assign({imageUrl:(r,{data:{imageUrl:s}})=>s,secret:(r,{data:{totpSecret:s}})=>s}),reportError:l.send((r,s)=>(console.log("REPORT",r,s),{type:"ERROR",error:r.error})),reportSuccess:l.send("SUCCESS"),reportGeneratedSuccess:l.send("GENERATED"),reportGeneratedError:l.send(r=>({type:"GENERATED_ERROR",error:r.error}))},guards:{invalidMfaCode:(r,{code:s})=>!s,invalidMfaType:(r,{activeMfaType:s})=>!s||s!=="totp"},services:{generate:async r=>{const{data:s}=await pe(`${t}/mfa/totp/generate`,e==null?void 0:e.getSnapshot().context.accessToken.value);return s},activate:(r,{code:s,activeMfaType:n})=>_(`${t}/user/mfa`,{code:s,activeMfaType:n},e==null?void 0:e.getSnapshot().context.accessToken.value)}}),ye=({backendUrl:t,clientUrl:e})=>l.createMachine({schema:{context:{},events:{},services:{}},tsTypes:{},predictableActionArguments:!0,id:"changePassword",initial:"idle",context:{error:null},states:{idle:{on:{REQUEST:[{cond:"invalidEmail",actions:"saveInvalidEmailError",target:".error"},{target:"requesting"}]},initial:"initial",states:{initial:{},success:{},error:{}}},requesting:{invoke:{src:"requestChange",id:"requestChange",onDone:{target:"idle.success",actions:"reportSuccess"},onError:{actions:["saveRequestError","reportError"],target:"idle.error"}}}}},{actions:{saveInvalidEmailError:l.assign({error:r=>y}),saveRequestError:l.assign({error:(r,{data:{error:s}})=>s}),reportError:l.send(r=>({type:"ERROR",error:r.error})),reportSuccess:l.send("SUCCESS")},guards:{invalidEmail:(r,{email:s})=>!A(s)},services:{requestChange:(r,{email:s,options:n})=>_(`${t}/user/password/reset`,{email:s,options:T(e,n)})}}),Ae=({backendUrl:t,clientUrl:e})=>l.createMachine({schema:{context:{},events:{},services:{}},tsTypes:{},predictableActionArguments:!0,id:"sendVerificationEmail",initial:"idle",context:{error:null},states:{idle:{on:{REQUEST:[{cond:"invalidEmail",actions:"saveInvalidEmailError",target:".error"},{target:"requesting"}]},initial:"initial",states:{initial:{},success:{},error:{}}},requesting:{invoke:{src:"request",id:"request",onDone:{target:"idle.success",actions:"reportSuccess"},onError:{actions:["saveRequestError","reportError"],target:"idle.error"}}}}},{actions:{saveInvalidEmailError:l.assign({error:r=>y}),saveRequestError:l.assign({error:(r,{data:{error:s}})=>s}),reportError:l.send(r=>({type:"ERROR",error:r.error})),reportSuccess:l.send("SUCCESS")},guards:{invalidEmail:(r,{email:s})=>!A(s)},services:{request:async(r,{email:s,options:n})=>(await _(`${t}/user/email/send-verification-email`,{email:s,options:T(e,n)})).data}});class J{constructor({clientStorageType:e="web",autoSignIn:r=!0,autoRefreshToken:s=!0,start:n=!0,backendUrl:i,clientUrl:u,devTools:h,...f}){if(this._started=!1,this._subscriptionsQueue=new Set,this._subscriptions=new Set,this.backendUrl=i,this.clientUrl=u,this._machine=Se({...f,backendUrl:i,clientUrl:u,clientStorageType:e,autoSignIn:r,autoRefreshToken:s}),n&&this.start({devTools:h}),typeof window!="undefined"&&r)try{this._channel=new BroadcastChannel("nhost"),this._channel.addEventListener("message",m=>{var o;const a=(o=this.interpreter)==null?void 0:o.getSnapshot().context.refreshToken.value;this.interpreter&&m.data!==a&&this.interpreter.send("TRY_TOKEN",{token:m.data})})}catch{}}start({devTools:e=!1,initialSession:r,interpreter:s}={}){var u,h;const n={...this.machine.context};r&&(n.user=r.user,n.refreshToken.value=(u=r.refreshToken)!=null?u:null,n.accessToken.value=(h=r.accessToken)!=null?h:null,n.accessToken.expiresAt=new Date(Date.now()+r.accessTokenExpiresIn*1e3));const i=this.machine.withContext(n);this._interpreter||(this._interpreter=s||l.interpret(i,{devTools:e})),(!this._started||typeof window=="undefined")&&(this._interpreter.initialized&&(this._interpreter.stop(),this._subscriptions.forEach(f=>f())),this._interpreter.start(i.initialState),this._subscriptionsQueue.forEach(f=>f(this))),this._started=!0}get machine(){return this._machine}get interpreter(){return this._interpreter}get started(){return this._started}subscribe(e){if(this.started){const r=e(this);return this._subscriptions.add(r),r}else return this._subscriptionsQueue.add(e),()=>{console.log("onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.")}}}class Re extends J{constructor({...e}){super({...e,autoSignIn:K()&&e.autoSignIn,autoRefreshToken:K()&&e.autoRefreshToken,clientStorageType:"cookie"})}}const er=Re,ke=async({backendUrl:t,interpreter:e},r)=>{try{const{data:s}=await _(`${t}/user/webauthn/add`,{},e==null?void 0:e.getSnapshot().context.accessToken.value);let n;try{n=await me(s)}catch(u){throw new b(u)}const{data:i}=await _(`${t}/user/webauthn/verify`,{credential:n,nickname:r},e==null?void 0:e.getSnapshot().context.accessToken.value);return{key:i,isError:!1,error:null,isSuccess:!0}}catch(s){const{error:n}=s;return{isError:!0,error:n,isSuccess:!1}}},ve=async(t,e,r)=>new Promise(s=>{t.send("REQUEST",{email:e,options:r}),t.onTransition(n=>{n.matches({idle:"error"})?s({error:n.context.error,isError:!0,needsEmailVerification:!1}):n.matches({idle:"success"})&&s({error:null,isError:!1,needsEmailVerification:!0})})}),Oe=async(t,e,r)=>new Promise(s=>{t.send("REQUEST",{password:e,ticket:r}),t.onTransition(n=>{n.matches({idle:"error"})?s({error:n.context.error,isError:!0,isSuccess:!1}):n.matches({idle:"success"})&&s({error:null,isError:!1,isSuccess:!0})})}),rr=t=>new Promise(e=>{t.send("GENERATE"),t.onTransition(r=>{r.matches("generated")?e({error:null,isError:!1,isGenerated:!0,qrCodeDataUrl:r.context.imageUrl||""}):r.matches({idle:"error"})&&e({error:r.context.error||null,isError:!0,isGenerated:!1,qrCodeDataUrl:""})})}),sr=(t,e)=>new Promise(r=>{t.send("ACTIVATE",{activeMfaType:"totp",code:e}),t.onTransition(s=>{s.matches({generated:"activated"})?r({error:null,isActivated:!0,isError:!1}):s.matches({generated:{idle:"error"}})&&r({error:s.context.error,isActivated:!1,isError:!0})})}),Pe=async(t,e,r)=>new Promise(s=>{t.send("REQUEST",{email:e,options:r}),t.onTransition(n=>{n.matches({idle:"error"})?s({error:n.context.error,isError:!0,isSent:!1}):n.matches({idle:"success"})&&s({error:null,isError:!1,isSent:!0})})}),Ne=(t,e,r)=>new Promise(s=>{t.send("REQUEST",{email:e,options:r}),t.onTransition(n=>{n.matches({idle:"error"})?s({error:n.context.error,isError:!0,isSent:!1}):n.matches({idle:"success"})&&s({error:null,isError:!1,isSent:!0})})}),Ce=t=>new Promise(e=>{const{changed:r}=t.send("SIGNIN_ANONYMOUS");r||e({isSuccess:!1,isError:!0,error:w,user:null,accessToken:null}),t.onTransition(s=>{s.matches({authentication:"signedIn"})&&e({isSuccess:!0,isError:!1,error:null,user:s.context.user,accessToken:s.context.accessToken.value}),s.matches({authentication:{signedOut:"failed"}})&&e({isSuccess:!1,isError:!0,error:s.context.errors.authentication||null,user:null,accessToken:null})})}),be=(t,e,r)=>new Promise(s=>{const{changed:n,context:i}=t.send("SIGNIN_PASSWORD",{email:e,password:r});if(!n)return s({accessToken:i.accessToken.value,error:w,isError:!0,isSuccess:!1,needsEmailVerification:!1,needsMfaOtp:!1,mfa:null,user:i.user});t.onTransition(u=>{u.matches({authentication:{signedOut:"noErrors"},registration:{incomplete:"needsEmailVerification"}})?s({accessToken:null,error:null,isError:!1,isSuccess:!1,needsEmailVerification:!0,needsMfaOtp:!1,mfa:null,user:null}):u.matches({authentication:{signedOut:"needsMfa"}})?s({accessToken:null,error:null,isError:!1,isSuccess:!1,needsEmailVerification:!1,needsMfaOtp:!0,mfa:u.context.mfa,user:null}):u.matches({authentication:{signedOut:"failed"}})?s({accessToken:null,error:u.context.errors.authentication||null,isError:!0,isSuccess:!1,needsEmailVerification:!1,needsMfaOtp:!1,mfa:null,user:null}):u.matches({authentication:"signedIn"})&&s({accessToken:u.context.accessToken.value,error:null,isError:!1,isSuccess:!0,needsEmailVerification:!1,needsMfaOtp:!1,mfa:null,user:u.context.user})})}),$=(t,e,r)=>new Promise(s=>{const{changed:n}=t.send("PASSWORDLESS_EMAIL",{email:e,options:r});if(!n)return s({error:w,isError:!0,isSuccess:!1});t.onTransition(i=>{i.matches("registration.incomplete.failed")?s({error:i.context.errors.registration||null,isError:!0,isSuccess:!1}):i.matches({authentication:{signedOut:"noErrors"},registration:{incomplete:"needsEmailVerification"}})&&s({error:null,isError:!1,isSuccess:!0})})}),De=(t,e)=>new Promise(r=>{const{changed:s,context:n}=t.send({type:"SIGNIN_SECURITY_KEY_EMAIL",email:e});if(!s)return r({accessToken:n.accessToken.value,error:w,isError:!0,isSuccess:!1,needsEmailVerification:!1,user:n.user});t.onTransition(i=>{i.matches({authentication:{signedOut:"noErrors"},registration:{incomplete:"needsEmailVerification"}})?r({accessToken:null,error:null,isError:!1,isSuccess:!1,needsEmailVerification:!0,user:null}):i.matches({authentication:{signedOut:"failed"}})?r({accessToken:null,error:i.context.errors.authentication||null,isError:!0,isSuccess:!1,needsEmailVerification:!1,user:null}):i.matches({authentication:"signedIn"})&&r({accessToken:i.context.accessToken.value,error:null,isError:!1,isSuccess:!0,needsEmailVerification:!1,user:i.context.user})})}),Me=(t,e,r)=>new Promise(s=>{const{changed:n,context:i}=t.send("SIGNIN_MFA_TOTP",{otp:e,ticket:r});if(!n)return s({accessToken:i.accessToken.value,error:w,isError:!0,isSuccess:!1,user:i.user});t.onTransition(u=>{u.matches({authentication:{signedOut:"failed"}})?s({accessToken:null,error:u.context.errors.authentication||null,isError:!0,isSuccess:!1,user:null}):u.matches({authentication:"signedIn"})&&s({accessToken:u.context.accessToken.value,error:null,isError:!1,isSuccess:!0,user:u.context.user})})}),xe=(t,e)=>new Promise(r=>{const{changed:s}=t.send("SIGNIN_PAT",{pat:e});s||r({isSuccess:!1,isError:!0,error:w,user:null,accessToken:null}),t.onTransition(n=>{if(n.matches({authentication:{signedOut:"failed"}}))return r({accessToken:null,user:null,error:n.context.errors.authentication||null,isError:!0,isSuccess:!1});if(n.matches({authentication:"signedIn"}))return r({accessToken:n.context.accessToken.value,user:n.context.user,error:null,isError:!1,isSuccess:!0})})}),Y=(t,e,r)=>new Promise(s=>{const{changed:n}=t.send("PASSWORDLESS_SMS",{phoneNumber:e,options:r});if(!n)return s({error:w,isError:!0,isSuccess:!1,needsOtp:!1});t.onTransition(i=>{i.matches("registration.incomplete.needsOtp")?s({error:null,isError:!1,isSuccess:!1,needsOtp:!0}):i.matches("registration.incomplete.failed")&&s({error:i.context.errors.authentication||null,isError:!0,isSuccess:!1,needsOtp:!1})})}),Ue=(t,e,r)=>new Promise(s=>{const{changed:n}=t.send({type:"PASSWORDLESS_SMS_OTP",phoneNumber:e,otp:r});if(!n)return s({error:w,isError:!0,isSuccess:!1,user:null,accessToken:null});t.onTransition(i=>{i.matches({authentication:"signedIn"})?s({error:null,isError:!1,isSuccess:!0,user:i.context.user,accessToken:i.context.accessToken.value}):i.matches({registration:{incomplete:"failed"}})&&s({error:i.context.errors.authentication||null,isError:!0,isSuccess:!1,user:null,accessToken:null})})}),Ke=async(t,e)=>new Promise(r=>{const{event:s}=t.send("SIGNOUT",{all:e});if(s.type!=="SIGNED_OUT")return r({isSuccess:!1,isError:!0,error:ae});t.onTransition(n=>{n.matches({authentication:{signedOut:"success"}})?r({isSuccess:!0,isError:!1,error:null}):n.matches("authentication.signedOut.failed")&&r({isSuccess:!1,isError:!0,error:n.context.errors.signout||null})})}),j=(t,e,r,s)=>new Promise(n=>{const{changed:i,context:u}=t.send("SIGNUP_EMAIL_PASSWORD",{email:e,password:r,options:s});if(!i)return n({error:w,accessToken:u.accessToken.value,isError:!0,isSuccess:!1,needsEmailVerification:!1,user:u.user});t.onTransition(h=>{h.matches("registration.incomplete.failed")?n({accessToken:null,error:h.context.errors.registration||null,isError:!0,isSuccess:!1,needsEmailVerification:!1,user:null}):h.matches({authentication:{signedOut:"noErrors"},registration:{incomplete:"needsEmailVerification"}})?n({accessToken:null,error:null,isError:!1,isSuccess:!1,needsEmailVerification:!0,user:null}):h.matches({authentication:"signedIn",registration:"complete"})&&n({accessToken:h.context.accessToken.value,error:null,isError:!1,isSuccess:!0,needsEmailVerification:!1,user:h.context.user})})}),Ve=(t,e,r)=>new Promise(s=>{const{changed:n,context:i}=t.send("SIGNUP_SECURITY_KEY",{email:e,options:r});if(!n)return s({error:w,accessToken:i.accessToken.value,isError:!0,isSuccess:!1,needsEmailVerification:!1,user:i.user});t.onTransition(u=>{u.matches("registration.incomplete.failed")?s({accessToken:null,error:u.context.errors.registration||null,isError:!0,isSuccess:!1,needsEmailVerification:!1,user:null}):u.matches({authentication:{signedOut:"noErrors"},registration:{incomplete:"needsEmailVerification"}})?s({accessToken:null,error:null,isError:!1,isSuccess:!1,needsEmailVerification:!0,user:null}):u.matches({authentication:"signedIn",registration:"complete"})&&s({accessToken:u.context.accessToken.value,error:null,isError:!1,isSuccess:!0,needsEmailVerification:!1,user:u.context.user})})}),tr=async({backendUrl:t,interpreter:e},{expiresAt:r,metadata:s})=>{try{const{data:n}=await _(`${t}/pat`,{expiresAt:r.toUTCString(),metadata:s},e==null?void 0:e.getSnapshot().context.accessToken.value);return{data:n?{id:n.id||null,personalAccessToken:n.personalAccessToken||null}:null,isError:!1,error:null,isSuccess:!0}}catch(n){const{error:i}=n;return{isError:!0,error:i,isSuccess:!1,data:null}}};class nr{constructor({url:e,autoRefreshToken:r=!0,autoSignIn:s=!0,clientStorage:n,clientStorageType:i,refreshIntervalTime:u,start:h=!0}){var f;this.url=e,this._client=new J({backendUrl:e,clientUrl:typeof window!="undefined"&&((f=window.location)==null?void 0:f.origin)||"",autoRefreshToken:r,autoSignIn:s,start:h,clientStorage:n,clientStorageType:i,refreshIntervalTime:u})}async signUp(e){const r=await this.waitUntilReady(),{email:s,options:n}=e;return"securityKey"in e?I(await Ve(r,s,n)):I(await j(r,s,e.password,n))}async signIn(e){const r=await this.waitUntilReady();if(!e){const s=await Ce(r);return{...I(s),mfa:null}}if("provider"in e){const{provider:s,options:n}=e,i=X(`${this._client.backendUrl}/signin/provider/${s}`,T(this._client.clientUrl,n));return K()&&(window.location.href=i),{providerUrl:i,provider:s,session:null,mfa:null,error:null}}if("email"in e&&"password"in e){const s=await be(r,e.email,e.password);return s.needsEmailVerification?{session:null,mfa:null,error:ce}:s.needsMfaOtp?{session:null,mfa:s.mfa,error:null}:{...I(s),mfa:null}}if("email"in e&&"securityKey"in e){if(e.securityKey!==!0)throw Error("securityKey must be true");const s=await De(r,e.email);return{...I(s),mfa:null}}if("email"in e){const{email:s,options:n}=e,{error:i}=await $(r,s,n);return{session:null,mfa:null,error:i}}if("phoneNumber"in e&&"otp"in e){const s=await Ue(r,e.phoneNumber,e.otp);return{...I(s),mfa:null}}if("phoneNumber"in e){const{error:s}=await Y(r,e.phoneNumber,e.options);return{error:s,mfa:null,session:null}}if("otp"in e){const s=await Me(r,e.otp,e.ticket);return{...I(s),mfa:null}}return{error:le,mfa:null,session:null}}async signInPAT(e){const r=await this.waitUntilReady(),s=await xe(r,e);return I(s)}async signOut(e){const r=await this.waitUntilReady(),{error:s}=await Ke(r,e==null?void 0:e.all);return{error:s}}async resetPassword({email:e,options:r}){const s=l.interpret(ye(this._client)).start(),{error:n}=await Pe(s,e,r);return{error:n}}async changePassword({newPassword:e,ticket:r}){const s=l.interpret(Ie(this._client)).start(),{error:n}=await Oe(s,e,r);return{error:n}}async sendVerificationEmail({email:e,options:r}){const s=l.interpret(Ae(this._client)).start(),{error:n}=await Ne(s,e,r);return{error:n}}async changeEmail({newEmail:e,options:r}){const s=l.interpret(_e(this._client)).start(),{error:n}=await ve(s,e,r);return{error:n}}async deanonymize(e){const r=await this.waitUntilReady();if(e.signInMethod==="passwordless"){if(e.connection==="email"){const{error:s}=await $(r,e.email,e.options);return{error:s}}if(e.connection==="sms"){const{error:s}=await Y(r,e.phoneNumber,e.options);return{error:s}}}if(e.signInMethod==="email-password"){const{error:s}=await j(r,e.email,e.password,e.options);return{error:s}}throw Error("Unknown deanonymization method")}async addSecurityKey(e){const{error:r,key:s}=await ke(this._client,e);return{error:r,key:s}}async createPAT(e,r){return tr(this._client,{expiresAt:e,metadata:r})}onTokenChanged(e){return this._client.subscribe(()=>{var s;const r=(s=this._client.interpreter)==null?void 0:s.onTransition(({event:n,context:i})=>{n.type==="TOKEN_CHANGED"&&e(N(i))});return()=>r==null?void 0:r.stop()})}onAuthStateChanged(e){return this._client.subscribe(()=>{var s;const r=(s=this._client.interpreter)==null?void 0:s.onTransition(({event:n,context:i})=>{(n.type==="SIGNED_IN"||n.type==="SIGNED_OUT")&&e(n.type,N(i))});return()=>r==null?void 0:r.stop()})}isAuthenticated(){var e;return!!((e=this._client.interpreter)!=null&&e.getSnapshot().matches({authentication:"signedIn"}))}async isAuthenticatedAsync(){return(await this.waitUntilReady()).getSnapshot().matches({authentication:"signedIn"})}getAuthenticationStatus(){var r;const e=((r=this.client.interpreter)==null?void 0:r.getSnapshot().context.importTokenAttempts)||0;return this.isReady()?{isAuthenticated:this.isAuthenticated(),isLoading:!1,connectionAttempts:e}:{isAuthenticated:!1,isLoading:!0,connectionAttempts:e}}getAccessToken(){var e,r;return(r=(e=this._client.interpreter)==null?void 0:e.getSnapshot().context.accessToken.value)!=null?r:void 0}getDecodedAccessToken(){const e=this.getAccessToken();return e?Ge(e):null}getHasuraClaims(){var e;return((e=this.getDecodedAccessToken())==null?void 0:e["https://hasura.io/jwt/claims"])||null}getHasuraClaim(e){var r;return((r=this.getHasuraClaims())==null?void 0:r[e.startsWith("x-hasura-")?e:`x-hasura-${e}`])||null}async refreshSession(e){try{const r=await this.waitUntilReady();return new Promise(s=>{const n=e||r.getSnapshot().context.refreshToken.value;if(!n)return s({session:null,error:ie});const{changed:i}=r.send("TRY_TOKEN",{token:n});if(!i)return s({session:null,error:oe});r.onTransition(u=>{u.matches({token:{idle:"error"}})?s({session:null,error:ue}):u.event.type==="TOKEN_CHANGED"&&s({session:N(u.context),error:null})})})}catch(r){return{session:null,error:r.message}}}getSession(){var e,r;return N((r=(e=this._client.interpreter)==null?void 0:e.getSnapshot())==null?void 0:r.context)}getUser(){var e,r,s;return((s=(r=(e=this._client.interpreter)==null?void 0:e.getSnapshot())==null?void 0:r.context)==null?void 0:s.user)||null}waitUntilReady(){const r=this._client.interpreter;if(!r)throw Error("Auth interpreter not set");return r.getSnapshot().hasTag("loading")?new Promise((s,n)=>{let i=setTimeout(()=>n("The state machine is not yet ready after 15 seconds."),15e3);r.onTransition(u=>{if(!u.hasTag("loading"))return clearTimeout(i),s(r)})}):Promise.resolve(r)}isReady(){var e,r;return!((r=(e=this._client.interpreter)==null?void 0:e.getSnapshot())!=null&&r.hasTag("loading"))}get client(){return this._client}}exports.AuthClient=J;exports.AuthClientSSR=er;exports.AuthCookieClient=Re;exports.CodifiedError=b;exports.EMAIL_NEEDS_VERIFICATION=ce;exports.HasuraAuthClient=nr;exports.INITIAL_MACHINE_CONTEXT=D;exports.INVALID_EMAIL_ERROR=y;exports.INVALID_MFA_CODE_ERROR=se;exports.INVALID_MFA_TICKET_ERROR=te;exports.INVALID_MFA_TYPE_ERROR=re;exports.INVALID_PASSWORD_ERROR=x;exports.INVALID_PHONE_NUMBER_ERROR=q;exports.INVALID_REFRESH_TOKEN=ue;exports.INVALID_SIGN_IN_METHOD=le;exports.MIN_PASSWORD_LENGTH=Z;exports.NETWORK_ERROR_CODE=B;exports.NHOST_JWT_EXPIRES_AT_KEY=R;exports.NHOST_REFRESH_TOKEN_ID_KEY=P;exports.NHOST_REFRESH_TOKEN_KEY=v;exports.NO_MFA_TICKET_ERROR=ne;exports.NO_REFRESH_TOKEN=ie;exports.OTHER_ERROR_CODE=Q;exports.REFRESH_TOKEN_MAX_ATTEMPTS=H;exports.STATE_ERROR_CODE=O;exports.TOKEN_REFRESHER_RUNNING_ERROR=oe;exports.TOKEN_REFRESH_MARGIN_SECONDS=ee;exports.USER_ALREADY_SIGNED_IN=w;exports.USER_NOT_ANONYMOUS=qe;exports.USER_UNAUTHENTICATED=ae;exports.VALIDATION_ERROR_CODE=p;exports.activateMfaPromise=sr;exports.addSecurityKeyPromise=ke;exports.changeEmailPromise=ve;exports.changePasswordPromise=Oe;exports.createAuthMachine=Se;exports.createChangeEmailMachine=_e;exports.createChangePasswordMachine=Ie;exports.createEnableMfaMachine=Ze;exports.createResetPasswordMachine=ye;exports.createSendVerificationEmailMachine=Ae;exports.encodeQueryParameters=X;exports.generateQrCodePromise=rr;exports.getAuthenticationResult=I;exports.getFetch=pe;exports.getParameterByName=C;exports.getSession=N;exports.isBrowser=K;exports.isValidEmail=A;exports.isValidPassword=V;exports.isValidPhoneNumber=F;exports.isValidTicket=we;exports.localStorageGetter=Ee;exports.localStorageSetter=ge;exports.postFetch=_;exports.removeParameterFromWindow=W;exports.resetPasswordPromise=Pe;exports.rewriteRedirectTo=T;exports.sendVerificationEmailPromise=Ne;exports.signInAnonymousPromise=Ce;exports.signInEmailPasswordPromise=be;exports.signInEmailPasswordlessPromise=$;exports.signInEmailSecurityKeyPromise=De;exports.signInMfaTotpPromise=Me;exports.signInPATPromise=xe;exports.signInSmsPasswordlessOtpPromise=Ue;exports.signInSmsPasswordlessPromise=Y;exports.signOutPromise=Ke;exports.signUpEmailPasswordPromise=j;exports.signUpEmailSecurityKeyPromise=Ve;
//# sourceMappingURL=index.cjs.js.map
