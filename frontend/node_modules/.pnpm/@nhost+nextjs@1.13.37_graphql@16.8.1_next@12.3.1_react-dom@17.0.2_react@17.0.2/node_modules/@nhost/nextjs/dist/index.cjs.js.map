{"version":3,"file":"index.cjs.js","sources":["../src/utils.ts","../src/create-server-side-client.ts","../src/get-session.ts","../src/index.ts"],"sourcesContent":["import { NhostClient, NhostSession } from '@nhost/react'\nimport fetch from 'isomorphic-unfetch'\nimport Cookies from 'js-cookie'\n\nexport const refresh = async (nhostUrl: string, refreshToken: string): Promise<NhostSession> => {\n  const result = await fetch(`${nhostUrl}/v1/auth/token`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ refreshToken })\n  })\n  if (result.ok) {\n    return result.json()\n  }\n  return Promise.reject(result.statusText)\n}\n\nexport const NHOST_SESSION_KEY = 'nhostSession'\n\nexport const setNhostSessionInCookie = (param: NhostClient | NhostSession | null) => {\n  const session = param && 'auth' in param ? param.auth.getSession() : param\n  if (!session) {\n    Cookies.remove(NHOST_SESSION_KEY)\n    return\n  }\n  const { refreshToken, ...rest } = session\n  const expires = new Date()\n  // * Expire the cookie 60 seconds before the token expires\n  expires.setSeconds(expires.getSeconds() + session.accessTokenExpiresIn - 60)\n  Cookies.set(NHOST_SESSION_KEY, JSON.stringify(rest), {\n    sameSite: 'strict',\n    expires\n  })\n}\n","import {\n  AuthMachine,\n  NHOST_REFRESH_TOKEN_KEY,\n  NhostClient,\n  NhostReactClientConstructorParams,\n  NhostSession,\n  VanillaNhostClient\n} from '@nhost/react'\nimport Cookies from 'js-cookie'\nimport { GetServerSidePropsContext } from 'next'\nimport { StateFrom } from 'xstate'\nimport { waitFor } from 'xstate/lib/waitFor'\nimport { NHOST_SESSION_KEY } from './utils'\n\nexport type CreateServerSideClientParams = Partial<\n  Pick<\n    NhostReactClientConstructorParams,\n    'subdomain' | 'region' | 'authUrl' | 'functionsUrl' | 'graphqlUrl' | 'storageUrl'\n  >\n>\n\n/**\n * Creates an Nhost client that runs on the server side.\n * It will try to get the refesh token in cookies, or from the request URL\n * If a refresh token is found, it uses it to get an up to date access token (JWT) and a user session\n * This method resolves when the authentication status is known eventually\n * @param config - An object containing connection information\n * @param context - Server side context\n * @returns instance of `NhostClient` that is ready to use on the server side (signed in or signed out)\n */\nexport const createServerSideClient = async (\n  params: string | CreateServerSideClientParams,\n  context: GetServerSidePropsContext\n): Promise<NhostClient> => {\n  let clientParams: NhostReactClientConstructorParams\n\n  if (typeof params === 'string') {\n    console.warn(\n      'Deprecation Notice: Backend URL is no longer supported. Please use subdomain + region or individual service URLs.'\n    )\n\n    clientParams = {\n      backendUrl: params\n    }\n  } else {\n    clientParams = {\n      ...params\n    }\n  }\n\n  const nhost = new VanillaNhostClient({\n    ...clientParams,\n    clientStorageType: 'custom',\n    clientStorage: {\n      getItem: (key) => {\n        // TODO does not perfectly work in the same way as the 'regular' client:\n        // in the authentication machine, if the refresh token is null but an error is found in the url, then the authentication stops and fails.\n        // * When the requested key is `NHOST_REFRESH_TOKEN_KEY`, we have to look for the given 'refreshToken' value\n        // * in the url as this is the key sent by hasura-auth\n        const urlKey = key === NHOST_REFRESH_TOKEN_KEY ? 'refreshToken' : key\n        const urlValue = context.query[urlKey]\n        const cookieValue = Cookies.get(key) ?? null\n        const nextCtxValue = context.req.cookies[key]\n\n        return typeof urlValue === 'string' ? urlValue : cookieValue ?? nextCtxValue\n      },\n      setItem: (key, value) => {\n        // TODO: Set expires based on the actual refresh token expire time\n        // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n        Cookies.set(key, value, { httpOnly: false, sameSite: 'strict', expires: 30 })\n      },\n      removeItem: (key) => {\n        Cookies.remove(key)\n      }\n    },\n    start: false,\n    autoRefreshToken: false,\n    autoSignIn: true\n  })\n\n  const strSession = context.req.cookies[NHOST_SESSION_KEY]\n  const refreshToken = context.req.cookies[NHOST_REFRESH_TOKEN_KEY]\n  const initialSession: NhostSession = strSession &&\n    refreshToken && { ...JSON.parse(strSession), refreshToken }\n\n  nhost.auth.client.start({ initialSession })\n  await waitFor(\n    nhost.auth.client.interpreter!,\n    (state: StateFrom<AuthMachine>) => !state.hasTag('loading')\n  )\n  return nhost\n}\n","import { NhostSession } from '@nhost/react'\nimport { GetServerSidePropsContext } from 'next'\nimport { createServerSideClient, CreateServerSideClientParams } from './create-server-side-client'\n\n/**\n * Refreshes the access token if there is any and returns the Nhost session.\n *\n * @example\n * ### Using an arrow function\n *\n * ```js\n * export const getServerSideProps: GetServerSideProps = async (context) => {\n *   const nhostSession = await getNhostSession(\n *     { subdomain: '<project_subdomain>', region: '<project_region>' },\n *     context\n *   )\n *\n *   return {\n *     props: {\n *       nhostSession\n *     }\n *   }\n * }\n * ```\n *\n * @example\n * ### Using a regular function\n *\n * ```js\n * export async function getServerSideProps(context: GetServerSidePropsContext) { // or NextPageContext\n *   const nhostSession = await getNhostSession(\n *     { subdomain: '<project_subdomain>', region: '<project_region>' },\n *     context\n *   )\n *\n *   return {\n *     props: {\n *       nhostSession\n *     }\n *   }\n * }\n * ```\n *\n * @param backendUrl - URL of your Nhost application\n * @param context - Next.js context\n * @returns Nhost session\n */\nexport const getNhostSession = async (\n  params: string | CreateServerSideClientParams,\n  context: GetServerSidePropsContext\n): Promise<NhostSession | null> => {\n  const nhost = await createServerSideClient(params, context)\n  const { accessToken, refreshToken, user } = nhost.auth.client.interpreter!.getSnapshot().context\n  return nhost.auth.isAuthenticated()\n    ? {\n        accessToken: accessToken.value!,\n        accessTokenExpiresIn: (accessToken.expiresAt!.getTime() - Date.now()) / 1_000,\n        refreshToken: refreshToken.value!,\n        user: user!\n      }\n    : null\n}\n","import {\n  NhostClient as ReactNhostClient,\n  NhostProvider,\n  NhostReactClientConstructorParams\n} from '@nhost/react'\nimport { setNhostSessionInCookie } from './utils'\n\nexport * from '@nhost/react'\nexport * from './create-server-side-client'\nexport * from './get-session'\n/**\n * @deprecated use `NhostProvider` instead\n */\nexport const NhostNextProvider: typeof NhostProvider = NhostProvider\n\nconst isBrowser = typeof window !== 'undefined'\n\nexport interface NhostNextClientConstructorParams\n  extends Omit<\n    NhostReactClientConstructorParams,\n    'clientStorage' | 'clientStorageType' | 'clientStorageGetter' | 'clientStorageSetter'\n  > {}\n\nexport class NhostClient extends ReactNhostClient {\n  constructor(params: NhostNextClientConstructorParams) {\n    super({\n      ...params,\n      autoSignIn: isBrowser && params.autoSignIn,\n      autoRefreshToken: isBrowser && params.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n\n    this.auth.onAuthStateChanged(() => {\n      setNhostSessionInCookie(this)\n    })\n    this.auth.onTokenChanged(setNhostSessionInCookie)\n  }\n}\n"],"names":["NHOST_SESSION_KEY","setNhostSessionInCookie","param","session","Cookies","refreshToken","rest","expires","createServerSideClient","params","context","clientParams","nhost","VanillaNhostClient","key","urlKey","NHOST_REFRESH_TOKEN_KEY","urlValue","cookieValue","_a","nextCtxValue","value","strSession","initialSession","waitFor","state","getNhostSession","accessToken","user","NhostNextProvider","NhostProvider","isBrowser","NhostClient","ReactNhostClient"],"mappings":"2MAkBaA,EAAoB,eAEpBC,EAA2BC,GAA6C,CACnF,MAAMC,EAAUD,GAAS,SAAUA,EAAQA,EAAM,KAAK,WAAe,EAAAA,EACrE,GAAI,CAACC,EAAS,CACZC,EAAQ,OAAOJ,CAAiB,EAChC,OAEF,KAAM,CAAE,aAAAK,EAAc,GAAGC,CAAA,EAASH,EAC5BI,MAAc,KAEpBA,EAAQ,WAAWA,EAAQ,WAAe,EAAAJ,EAAQ,qBAAuB,EAAE,EAC3EC,EAAQ,IAAIJ,EAAmB,KAAK,UAAUM,CAAI,EAAG,CACnD,SAAU,SACV,QAAAC,CAAA,CACD,CACH,ECJaC,EAAyB,MACpCC,EACAC,IACyB,CACrB,IAAAC,EAEA,OAAOF,GAAW,UACZ,QAAA,KACN,mHAAA,EAGaE,EAAA,CACb,WAAYF,CAAA,GAGCE,EAAA,CACb,GAAGF,CAAA,EAID,MAAAG,EAAQ,IAAIC,qBAAmB,CACnC,GAAGF,EACH,kBAAmB,SACnB,cAAe,CACb,QAAUG,GAAQ,OAKV,MAAAC,EAASD,IAAQE,0BAA0B,eAAiBF,EAC5DG,EAAWP,EAAQ,MAAMK,CAAM,EAC/BG,GAAcC,EAAAf,EAAQ,IAAIU,CAAG,IAAf,KAAAK,EAAoB,KAClCC,EAAeV,EAAQ,IAAI,QAAQI,CAAG,EAE5C,OAAO,OAAOG,GAAa,SAAWA,EAAWC,GAAA,KAAAA,EAAeE,CAClE,EACA,QAAS,CAACN,EAAKO,IAAU,CAGfjB,EAAA,IAAIU,EAAKO,EAAO,CAAE,SAAU,GAAO,SAAU,SAAU,QAAS,EAAI,CAAA,CAC9E,EACA,WAAaP,GAAQ,CACnBV,EAAQ,OAAOU,CAAG,CACpB,CACF,EACA,MAAO,GACP,iBAAkB,GAClB,WAAY,EAAA,CACb,EAEKQ,EAAaZ,EAAQ,IAAI,QAAQV,CAAiB,EAClDK,EAAeK,EAAQ,IAAI,QAAQM,EAAuB,uBAAA,EAC1DO,EAA+BD,GACnCjB,GAAgB,CAAE,GAAG,KAAK,MAAMiB,CAAU,EAAG,aAAAjB,GAE/C,OAAAO,EAAM,KAAK,OAAO,MAAM,CAAE,eAAAW,CAAgB,CAAA,EACpC,MAAAC,EAAA,QACJZ,EAAM,KAAK,OAAO,YACjBa,GAAkC,CAACA,EAAM,OAAO,SAAS,CAAA,EAErDb,CACT,EC5Cac,EAAkB,MAC7BjB,EACAC,IACiC,CACjC,MAAME,EAAQ,MAAMJ,EAAuBC,EAAQC,CAAO,EACpD,CAAE,YAAAiB,EAAa,aAAAtB,EAAc,KAAAuB,GAAShB,EAAM,KAAK,OAAO,YAAa,YAAA,EAAc,QAClF,OAAAA,EAAM,KAAK,kBACd,CACE,YAAae,EAAY,MACzB,sBAAuBA,EAAY,UAAW,UAAY,KAAK,OAAS,IACxE,aAActB,EAAa,MAC3B,KAAAuB,CAEF,EAAA,IACN,EChDaC,EAA0CC,EAAA,cAEjDC,EAAY,OAAO,QAAW,YAQ7B,MAAMC,UAAoBC,EAAAA,WAAiB,CAChD,YAAYxB,EAA0C,CAC9C,MAAA,CACJ,GAAGA,EACH,WAAYsB,GAAatB,EAAO,WAChC,iBAAkBsB,GAAatB,EAAO,iBACtC,kBAAmB,QAAA,CACpB,EAEI,KAAA,KAAK,mBAAmB,IAAM,CACjCR,EAAwB,IAAI,CAAA,CAC7B,EACI,KAAA,KAAK,eAAeA,CAAuB,CAClD,CACF"}