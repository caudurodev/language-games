import { NhostClient as O, addSecurityKeyPromise as C, createChangeEmailMachine as L, changeEmailPromise as M, createChangePasswordMachine as N, changePasswordPromise as R, createEnableMfaMachine as V, generateQrCodePromise as D, activateMfaPromise as K, createFileUploadMachine as F, uploadFilePromise as _, createMultipleFilesUploadMachine as q, uploadMultipleFilesPromise as H, encodeQueryParameters as Q, rewriteRedirectTo as $, createResetPasswordMachine as j, resetPasswordPromise as G, createSendVerificationEmailMachine as J, sendVerificationEmailPromise as Y, signInAnonymousPromise as W, signInEmailPasswordPromise as z, signInMfaTotpPromise as B, signInEmailPasswordlessPromise as X, signInEmailSecurityKeyPromise as Z, signInPATPromise as b, signInSmsPasswordlessPromise as ee, signInSmsPasswordlessOtpPromise as A, signOutPromise as te, signUpEmailPasswordPromise as se, signUpEmailSecurityKeyPromise as ne } from "@nhost/nhost-js";
import { NHOST_REFRESH_TOKEN_KEY as et } from "@nhost/nhost-js";
import oe, { createContext as re, useRef as ce, useEffect as y, useContext as w, createElement as T, Fragment as U, useState as x, useMemo as P, useCallback as ie } from "react";
import { useInterpret as f, useSelector as n } from "@xstate/react";
import ae from "jwt-decode";
const ue = O;
class xe extends ue {
  constructor(e) {
    super({ ...e, start: !1 });
  }
}
const I = re({}), le = ({
  nhost: t,
  initial: e,
  ...s
}) => {
  const a = f(t.auth.client.machine, { devTools: t.devTools });
  t.auth.client.start({ interpreter: a, initialSession: e, devTools: t.devTools });
  const h = ce(!0);
  return y(() => {
    h.current ? h.current = !1 : e && a.send("SESSION_UPDATE", { data: { session: e } });
  }, [e, a]), /* @__PURE__ */ oe.createElement(I.Provider, { value: t }, s.children);
}, ve = le, E = () => {
  var s;
  const e = (s = w(I).auth) == null ? void 0 : s.client.interpreter;
  if (!e)
    throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
  return e;
}, k = () => {
  const t = E();
  return n(
    t,
    (e) => ({
      isAuthenticated: e.matches({ authentication: "signedIn" }),
      isLoading: e.hasTag("loading"),
      error: e.context.errors.authentication || null,
      isError: e.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: e.context.importTokenAttempts
    }),
    (e, s) => e.isAuthenticated === s.isAuthenticated && e.isLoading === s.isLoading && e.connectionAttempts === s.connectionAttempts
  );
};
function Pe({ children: t }) {
  const { isAuthenticated: e } = k();
  return e ? T(U, null, t) : null;
}
function Ie({ children: t }) {
  const { isAuthenticated: e } = k();
  return e ? null : T(U, null, t);
}
const de = () => {
  const t = E();
  return n(t, (e) => e.context.accessToken.value);
}, S = () => w(I), ye = () => {
  const t = S(), [e, s] = x(null), a = !e, h = !!e, [u, g] = x(!1);
  return { add: async (r) => {
    g(!0);
    const o = await C(t.auth.client, r), { error: c } = o;
    return c && s(c), g(!1), o;
  }, isLoading: u, isSuccess: a, isError: h, error: e };
}, we = () => {
  const t = E(), [e, s] = x(
    !!t.status && t.getSnapshot().matches({ authentication: "signedIn" })
  );
  return y(() => t.subscribe((h) => {
    const u = h.matches({ authentication: "signedIn" });
    s(u);
  }).unsubscribe, [t]), e;
};
function Ae(t) {
  const e = S(), s = P(() => L(e.auth.client), [e]), a = f(s), h = n(a, (o) => o.matches("requesting")), u = n(a, (o) => o.context.error), g = n(a, (o) => o.matches("idle.error")), d = n(a, (o) => o.matches("idle.success"));
  return { changeEmail: ie(
    async (o, c = t) => M(a, o, c),
    [a, t]
  ), isLoading: h, needsEmailVerification: d, isError: g, error: u };
}
const Te = () => {
  const t = S(), e = P(() => N(t.auth.client), [t]), s = f(e), a = n(s, (r) => r.matches({ idle: "error" })), h = n(s, (r) => r.matches({ idle: "success" })), u = n(s, (r) => r.context.error), g = n(s, (r) => r.matches("requesting"));
  return { changePassword: (r) => R(s, r), isLoading: g, isSuccess: h, isError: a, error: u };
}, Ue = () => {
  const t = S(), e = P(() => V(t.auth.client), [t]), s = f(e), a = n(
    s,
    (i) => i.matches({ idle: "error" }) || i.matches({ generated: { idle: "error" } })
  ), h = n(s, (i) => i.matches("generating")), u = n(s, (i) => i.matches("generated")), g = n(s, (i) => i.matches({ generated: "activating" })), d = n(s, (i) => i.matches({ generated: "activated" })), r = n(s, (i) => i.context.error), o = n(s, (i) => i.context.imageUrl || "");
  return {
    generateQrCode: () => D(s),
    isGenerating: h,
    qrCodeDataUrl: o,
    isGenerated: u,
    activateMfa: (i) => K(s, i),
    isActivating: g,
    isActivated: d,
    isError: a,
    error: r
  };
}, me = () => {
  const t = de();
  return t ? ae(t) : null;
}, he = (t) => {
  const e = S(), s = (p) => {
    t.send({
      type: "ADD",
      file: p.file,
      bucketId: p.bucketId || i
    });
  }, a = (p) => _(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...p
    },
    t
  ), h = () => {
    t.send("CANCEL");
  }, u = () => {
    t.send("DESTROY");
  }, g = n(t, (p) => p.matches("uploading")), d = n(t, (p) => p.matches("uploaded")), r = n(t, (p) => p.matches("error")), o = n(t, (p) => p.context.error || null), c = n(t, (p) => p.context.progress), l = n(t, (p) => p.context.id), i = n(t, (p) => p.context.bucketId), m = n(t, (p) => {
    var v;
    return (v = p.context.file) == null ? void 0 : v.name;
  });
  return {
    add: s,
    upload: a,
    cancel: h,
    destroy: u,
    isUploaded: d,
    isUploading: g,
    isError: r,
    error: o,
    progress: c,
    id: l,
    bucketId: i,
    name: m
  };
}, ke = () => {
  const t = f(F);
  return he(t);
}, ge = () => {
  const t = me();
  return (t == null ? void 0 : t["https://hasura.io/jwt/claims"]) || null;
}, Oe = (t) => {
  const e = ge();
  return (e == null ? void 0 : e[t.startsWith("x-hasura-") ? t : `x-hasura-${t}`]) || null;
}, Ce = () => {
  const t = S(), [e, s] = x([]), a = f(q, {}, (m) => {
    m.event.type === "UPLOAD_ERROR" ? s(m.context.files.filter((p) => {
      var v;
      return (v = p.getSnapshot()) == null ? void 0 : v.context.error;
    })) : (m.matches("uploaded") || m.event.type === "CLEAR") && e.length > 0 && s([]);
  }), h = (m) => {
    a.send({ type: "ADD", ...m });
  }, u = (m) => H(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...m
    },
    a
  ), g = () => {
    a.send("CANCEL");
  }, d = () => {
    a.send("CLEAR");
  }, r = n(a, (m) => m.matches("uploading")), o = n(a, (m) => m.matches("uploaded")), c = n(a, (m) => m.matches("error")), l = n(a, (m) => m.context.progress), i = n(a, (m) => m.context.files);
  return {
    upload: u,
    add: h,
    clear: d,
    cancel: g,
    progress: l,
    isUploaded: o,
    isUploading: r,
    files: i,
    isError: c,
    errors: e
  };
}, Le = (t) => {
  const [e, s] = x(!0);
  y(() => {
    s(!1);
  }, []);
  const a = w(I);
  return new Proxy({}, {
    get(h, u) {
      return Q(
        `${a.auth.client.backendUrl}/signin/provider/${u}`,
        $(e ? void 0 : a.auth.client.clientUrl, t)
      );
    }
  });
}, Me = (t) => {
  const e = S(), s = P(() => j(e.auth.client), [e]), a = f(s), h = n(a, (o) => o.matches("requesting")), u = n(a, (o) => o.context.error), g = n(a, (o) => o.matches("idle.error")), d = n(a, (o) => o.matches("idle.success"));
  return { resetPassword: (o, c = t) => G(a, o, c), isLoading: h, isSent: d, isError: g, error: u };
}, Ne = (t) => {
  const e = S(), s = P(() => J(e.auth.client), [e]), a = f(s), h = n(a, (o) => o.matches({ idle: "error" })), u = n(a, (o) => o.matches({ idle: "success" })), g = n(a, (o) => o.context.error), d = n(a, (o) => o.matches("requesting"));
  return { sendEmail: (o, c = t) => Y(a, o, c), isLoading: d, isSent: u, isError: h, error: g };
}, Re = () => {
  const t = E(), e = () => W(t), s = n(
    t,
    (r) => r.context.errors.authentication || null,
    (r, o) => (r == null ? void 0 : r.error) === (o == null ? void 0 : o.error)
  ), a = n(
    t,
    (r) => r.matches({ authentication: { authenticating: "anonymous" } })
  ), h = n(
    t,
    (r) => r.matches({
      authentication: "signedIn"
    })
  ), u = n(
    t,
    (r) => r.matches({ authentication: { signedOut: "failed" } })
  ), g = n(
    t,
    (r) => r.context.user,
    (r, o) => (r == null ? void 0 : r.id) === (o == null ? void 0 : o.id)
  );
  return { accessToken: n(t, (r) => r.context.accessToken.value), error: s, isError: u, isLoading: a, isSuccess: h, signInAnonymous: e, user: g };
}, Ve = () => {
  const t = E(), e = (i, m) => z(t, i, m), s = (i) => B(t, i), a = n(
    t,
    (i) => i.context.user,
    (i, m) => (i == null ? void 0 : i.id) === (m == null ? void 0 : m.id)
  ), h = n(t, (i) => i.context.accessToken.value), u = n(
    t,
    (i) => i.context.errors.authentication || null,
    (i, m) => (i == null ? void 0 : i.error) === (m == null ? void 0 : m.error)
  ), g = n(
    t,
    (i) => i.matches({
      authentication: "signedIn"
    })
  ), d = n(
    t,
    (i) => i.matches({ authentication: { authenticating: "password" } }),
    (i, m) => i === m
  ), r = n(
    t,
    (i) => i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (i, m) => i === m
  ), o = n(
    t,
    (i) => i.matches({ authentication: { signedOut: "needsMfa" } }),
    (i, m) => i === m
  ), c = n(
    t,
    (i) => i.matches({ authentication: { signedOut: "failed" } }),
    (i, m) => i === m
  ), l = n(t, (i) => i.context.mfa);
  return {
    accessToken: h,
    error: u,
    isError: c,
    isLoading: d,
    isSuccess: g,
    needsEmailVerification: r,
    needsMfaOtp: o,
    mfa: l,
    sendMfaOtp: s,
    signInEmailPassword: e,
    user: a
  };
};
function De(t) {
  const e = E(), s = (d, r = t) => X(e, d, r), a = n(
    e,
    (d) => d.context.errors.registration || null,
    (d, r) => (d == null ? void 0 : d.error) === (r == null ? void 0 : r.error)
  ), h = n(e, (d) => d.matches("registration.passwordlessEmail")), u = n(
    e,
    (d) => d.matches("registration.incomplete.needsEmailVerification")
  ), g = n(e, (d) => d.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: s, isLoading: h, isSuccess: u, isError: g, error: a };
}
const Ke = () => {
  const t = E(), e = (o) => Z(t, o), s = n(
    t,
    (o) => o.context.user,
    (o, c) => (o == null ? void 0 : o.id) === (c == null ? void 0 : c.id)
  ), a = n(t, (o) => o.context.accessToken.value), h = n(
    t,
    (o) => o.context.errors.authentication || null,
    (o, c) => (o == null ? void 0 : o.error) === (c == null ? void 0 : c.error)
  ), u = n(
    t,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), g = n(
    t,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, c) => o === c
  ), d = n(
    t,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, c) => o === c
  ), r = n(
    t,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, c) => o === c
  );
  return {
    accessToken: a,
    error: h,
    isError: r,
    isLoading: g,
    isSuccess: u,
    needsEmailVerification: d,
    signInEmailSecurityKey: e,
    user: s
  };
}, Fe = () => {
  const t = E(), e = (r) => b(t, r), s = n(
    t,
    (r) => r.context.user,
    (r, o) => (r == null ? void 0 : r.id) === (o == null ? void 0 : o.id)
  ), a = n(t, (r) => r.context.accessToken.value), h = n(
    t,
    (r) => r.context.errors.authentication || null,
    (r, o) => (r == null ? void 0 : r.error) === (o == null ? void 0 : o.error)
  ), u = n(t, (r) => r.matches({ authentication: "signedIn" })), g = n(
    t,
    (r) => r.matches({ authentication: { authenticating: "password" } }),
    (r, o) => r === o
  ), d = n(
    t,
    (r) => r.matches({ authentication: { signedOut: "failed" } }),
    (r, o) => r === o
  );
  return {
    accessToken: a,
    error: h,
    isError: d,
    isLoading: g,
    isSuccess: u,
    signInPAT: e,
    user: s
  };
};
function _e(t) {
  const e = E(), [s, a] = x(""), h = (l, i = t) => (a(l), ee(e, l, i)), u = async (...l) => {
    if (l.length === 2) {
      const [m, p] = l;
      return A(e, m, p);
    }
    const [i] = l;
    return A(e, s, i);
  }, g = n(
    e,
    (l) => l.context.errors.registration || null,
    (l, i) => (l == null ? void 0 : l.error) === (i == null ? void 0 : i.error)
  ), d = n(
    e,
    (l) => l.matches("registration.passwordlessSms") || l.matches("registration.passwordlessSmsOtp")
  ), r = n(e, (l) => l.matches("authentication.signedIn")), o = n(
    e,
    (l) => l.matches("registration.incomplete.needsOtp")
  ), c = n(e, (l) => l.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: h, sendOtp: u, isLoading: d, isSuccess: r, needsOtp: o, isError: c, error: g };
}
const qe = (t = !1) => {
  const e = E(), s = (u) => te(e, typeof u == "boolean" ? u : t), a = n(
    e,
    (u) => u.matches({ authentication: { signedOut: "success" } }),
    (u, g) => u === g
  ), h = n(
    e,
    (u) => u.context.errors.signout || null,
    (u, g) => (u == null ? void 0 : u.error) === (g == null ? void 0 : g.error)
  );
  return { signOut: s, isSuccess: a, error: h };
}, He = (t) => {
  const e = E(), s = n(e, (c) => !!c.context.errors.registration), a = n(
    e,
    (c) => c.context.errors.registration || null,
    (c, l) => (c == null ? void 0 : c.error) === (l == null ? void 0 : l.error)
  ), h = n(e, (c) => c.matches("registration.emailPassword")), u = n(
    e,
    (c) => c.matches("registration.incomplete.needsEmailVerification")
  ), g = n(
    e,
    (c) => c.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), d = (c, l, i = t) => se(e, c, l, i), r = n(
    e,
    (c) => c.context.user,
    (c, l) => (c == null ? void 0 : c.id) === (l == null ? void 0 : l.id)
  );
  return {
    accessToken: n(e, (c) => c.context.accessToken.value),
    error: a,
    isError: s,
    isLoading: h,
    isSuccess: g,
    needsEmailVerification: u,
    signUpEmailPassword: d,
    user: r
  };
}, Qe = (t) => {
  const e = E(), s = n(e, (c) => !!c.context.errors.registration), a = n(
    e,
    (c) => c.context.errors.registration || null,
    (c, l) => (c == null ? void 0 : c.error) === (l == null ? void 0 : l.error)
  ), h = n(e, (c) => c.matches("registration.securityKey")), u = n(
    e,
    (c) => c.matches("registration.incomplete.needsEmailVerification")
  ), g = n(
    e,
    (c) => c.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), d = (c, l = t) => ne(e, c, l), r = n(
    e,
    (c) => c.context.user,
    (c, l) => (c == null ? void 0 : c.id) === (l == null ? void 0 : l.id)
  );
  return {
    accessToken: n(e, (c) => c.context.accessToken.value),
    error: a,
    isError: s,
    isLoading: h,
    isSuccess: g,
    needsEmailVerification: u,
    signUpEmailSecurityKey: d,
    user: r
  };
}, $e = () => {
  const t = E();
  return n(
    t,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.avatarUrl;
    },
    (e, s) => e === s
  );
}, je = () => {
  const t = E();
  return n(
    t,
    (e) => e.context.user,
    (e, s) => (e && JSON.stringify(e)) === (s && JSON.stringify(s))
  );
}, Ge = () => {
  const t = E();
  return n(
    t,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.defaultRole;
    },
    (e, s) => e === s
  );
}, Je = () => {
  const t = E();
  return n(
    t,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.displayName;
    },
    (e, s) => e === s
  );
}, Ye = () => {
  const t = E();
  return n(
    t,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.email;
    },
    (e, s) => e === s
  );
}, We = () => {
  const t = E();
  return n(
    t,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.id;
    },
    (e, s) => e === s
  );
}, ze = () => {
  const t = E();
  return n(
    t,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.isAnonymous;
    },
    (e, s) => e === s
  );
}, Be = () => {
  const t = E();
  return n(
    t,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.locale;
    },
    (e, s) => e === s
  );
}, Xe = () => {
  const t = E();
  return n(t, (e) => {
    var s;
    return e.matches("authentication.signedIn") ? ((s = e.context.user) == null ? void 0 : s.roles) || [] : [];
  });
};
export {
  et as NHOST_REFRESH_TOKEN_KEY,
  xe as NhostClient,
  le as NhostProvider,
  I as NhostReactContext,
  ve as NhostReactProvider,
  Pe as SignedIn,
  Ie as SignedOut,
  ue as VanillaNhostClient,
  de as useAccessToken,
  ye as useAddSecurityKey,
  E as useAuthInterpreter,
  we as useAuthenticated,
  k as useAuthenticationStatus,
  Ae as useChangeEmail,
  Te as useChangePassword,
  Ue as useConfigMfa,
  me as useDecodedAccessToken,
  ke as useFileUpload,
  he as useFileUploadItem,
  Oe as useHasuraClaim,
  ge as useHasuraClaims,
  Ce as useMultipleFilesUpload,
  S as useNhostClient,
  Le as useProviderLink,
  Me as useResetPassword,
  Ne as useSendVerificationEmail,
  Re as useSignInAnonymous,
  Ve as useSignInEmailPassword,
  De as useSignInEmailPasswordless,
  Ke as useSignInEmailSecurityKey,
  Fe as useSignInPAT,
  _e as useSignInSmsPasswordless,
  qe as useSignOut,
  He as useSignUpEmailPassword,
  Qe as useSignUpEmailSecurityKeyEmail,
  $e as useUserAvatarUrl,
  je as useUserData,
  Ge as useUserDefaultRole,
  Je as useUserDisplayName,
  Ye as useUserEmail,
  We as useUserId,
  ze as useUserIsAnonymous,
  Be as useUserLocale,
  Xe as useUserRoles
};
//# sourceMappingURL=index.esm.js.map
